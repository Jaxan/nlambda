- dokumentacja za pomoca haddock,
- pragma MINIMAL 
- stworzyc listy eksportowe dla modułów,

- Formula: 
-- przenieść ifFormula i dodać simplify i solve,
-- ew. przeniesc upraszczanie formul do oddzielnego modułu
-- poprawić nawiasowanie przy kwantyfikatorach
-- w formule trzymać zbiór zmiennych wolnych
-- upraszczanie: 
-- ustawić infixl dla operatorów,
--- (a /\ b) \/ (a /\ not b) -> a, 
--- (a \/ b) /\ (a \/ not b) -> a /\ not b
--- a /\ b /\ a -> a /\ b (pewnie ory i and będą na zbiorach), itp.

- Nominal:
-- zastanowić się jaki ma być "strict",
-- dodac instancje dla NominalType, Conditional: Either, Maybe, Map, Set
-- pomyśleć nad odpowiednikami operacji z ' na koncu, ktore czesciej rozwiazuja formuly (ewentualnie za pomoca makra #define),
-- sprawdzic czy potrzebne sa wewnetrzne optymalne funkcje: isSubsetOf, intersection, difference.
-- zaimplementować pairs i podobne,
-- dodać typ liniowy i klasę z funkcjami: le, lt, ge, gt.
-- pomyśleć nad problemem rozwiązywania konfliktu nazw zmiennych iteracyjnych - czy istnieje rozwiązanie "strict"?
-- pomyśleć nad problemem obliczania wsparcia dla zbioru: insert a atomSet - może przy "insert" trzeba sprawdzić "contains", czyli rozwiązać formułę

-- rozmiar zbioru, fold - krata, obliczanie maxa dla funkcji Atom -> Int
-- automatyczne wyliczanie formuł
-- upraszczanie formuł (moze za pomocą Z3)
-- programy: spojność w grafie, minimalizacji automatu

SPRAWDZIĆ:
- eq atomSet atomSet
- filter (contains $ delete a sa) sa
- iF cond [] [a]
