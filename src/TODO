- dodać moduł BinaryRelation z ktorego bedzie korzystał graph
- specjalny show dla prostego zbioru atomów
- pomyśleć nad kratą dla folda na zbiorze nominalnym


- dokumentacja za pomoca haddock,
- pragma MINIMAL 
- stworzyc listy eksportowe dla modułów,
- napisać testy jednostkowe

- Formula: 
-- przenieść ifFormula i dodać simplify i solve,
-- ew. przeniesc upraszczanie formul do oddzielnego modułu
-- poprawić nawiasowanie przy kwantyfikatorach
-- w formule trzymać zbiór zmiennych wolnych
-- upraszczanie: 
-- ustawić infixl dla operatorów,
--- (a /\ b) \/ (a /\ not b) -> a, 
--- (a \/ b) /\ (a \/ not b) -> a /\ not b
--- a /\ b /\ a -> a /\ b (pewnie ory i and będą na zbiorach), itp.

- Nominal:
-- zastanowić się jaki ma być "strict",
-- dodac instancje dla NominalType, Conditional: Either, Maybe, Map, Set
-- pomyśleć nad odpowiednikami operacji z ' na koncu, ktore czesciej rozwiazuja formuly (ewentualnie za pomoca makra #define),
-- sprawdzic czy potrzebne sa wewnetrzne optymalne funkcje: isSubsetOf, intersection, difference.
-- zaimplementować pairs i podobne,
-- dodać typ liniowy i klasę z funkcjami: le, lt, ge, gt.
-- pomyśleć nad problemem rozwiązywania konfliktu nazw zmiennych iteracyjnych - czy istnieje rozwiązanie "strict"?
-- pomyśleć nad problemem obliczania wsparcia dla zbioru: insert a atomSet - może przy "insert" trzeba sprawdzić "contains", czyli rozwiązać formułę
-- rozwiązywanie konfliktów zmiennych - poziomy zgodnie z zagnieżdzeniem, a nie: {{{(a₁,c₁,b₁) : for b₁ ∊ 𝔸} : for c₁ ∊ 𝔸} : for a₁ ∊ 𝔸}

-- rozmiar zbioru, fold - krata, obliczanie maxa dla funkcji Atom -> Int
-- automatyczne wyliczanie formuł
-- upraszczanie formuł (moze za pomocą Z3)
-- programy: spojność w grafie, minimalizacji automatu

SPRAWDZIĆ:
- eq atomSet atomSet
- filter (contains $ delete a sa) sa
- iF cond [] [a]

Algorytmy:
- zbiory:
-- istnieje ekwiwariantna bijekcja: (A\{a} A\{b} {a,b})
- grafy:
-- dwudzielnosc,
-- trojkolorowalnosc,
-- dijkstra,
-- osiagalnosc,
- automaty:
-- minimalizacja,
-- rownowaznosc.
